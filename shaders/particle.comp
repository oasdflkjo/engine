#version 430
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std430, binding = 0) buffer Position {
    vec2 positions[];
};

layout(std430, binding = 1) buffer Velocity {
    vec2 velocities[];
};

layout(std430, binding = 2) buffer VelocityMagnitude {
    float velocityMags[];
};

// Time and particle count uniforms
uniform float delta_time;
uniform int num_particles;
uniform int particle_offset;
uniform int batch_size;

// Mouse interaction
uniform vec2 mouse_pos;
uniform float mouse_force_radius;
uniform float mouse_force_strength;

// Physics parameters
uniform float min_distance;         // Minimum distance before force is applied
uniform float force_scale;         // Base force scaling factor
uniform float max_force;           // Maximum force that can be applied
uniform float terminal_velocity;   // Maximum speed
uniform float damping;            // Velocity damping factor

void main() {
    uint global_id = gl_GlobalInvocationID.x + 
                    gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x);
                    
    uint particle_id = particle_offset + global_id;
    if (particle_id >= num_particles) return;

    vec2 pos = positions[particle_id];
    vec2 vel = velocities[particle_id];
    
    // Update position
    pos += vel * delta_time;
    
    // Calculate force towards mouse
    vec2 to_mouse = mouse_pos - pos;
    float dist = length(to_mouse);
    
    if (dist > min_distance) {
        float force_strength = force_scale / (dist + 1.0);
        force_strength = min(force_strength, max_force);
        
        vel += normalize(to_mouse) * force_strength * delta_time;
    }
    
    // Apply velocity limits
    float speed = length(vel);
    if (speed > terminal_velocity) {
        vel = normalize(vel) * terminal_velocity;
    }
    
    // Apply dampening
    vel *= 1.0 - (damping * delta_time);
    
    // Store results
    positions[particle_id] = pos;
    velocities[particle_id] = vel;
    velocityMags[particle_id] = length(vel);
}